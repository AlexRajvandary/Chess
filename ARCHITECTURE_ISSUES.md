# Архитектурные проблемы проекта Chess

## Архитектурная идея проекта

**Правильная идея:** Проект должен иметь четкое разделение:
- **ChessLib** - библиотека с бизнес-логикой (правила игры, фигуры, валидация ходов)
- **Console View** - консольное представление (chess проект)
- **WPF View** - графическое представление (WPFChess проект)

**Проблема:** Эта идея не полностью реализована - консольная логика попала в библиотеку, а бизнес-логика попала в ViewModel.

---

## 1. Нарушение разделения слоев - консольная логика в библиотеке

### 1.1. Методы консольного ввода в `Game` (ChessLib)
**Проблема:** В библиотеке `ChessLib` есть методы, специфичные для консольного представления:
- `UserInput(int)` - чтение из `Console.ReadLine()` (строка 41-51)
- `ChosePiece()` - консольный выбор фигуры с нумерацией (строка 270-290)
- `ShowAvailableMoves()` - вывод в консоль (строка 215-231)
- `ShowAvailableAttacks()` - вывод в консоль (строка 196-213)
- `ConsoleMove()` - консольная логика хода (строка 142-194)
- `MoveAfterCheck()` - консольная логика шаха (строка 298-338)
- `GameProcess()` - консольный игровой цикл с `Console.Clear()` и `Console.ReadLine()` (строка 350-371)

**Местоположение:** `ChessLib/Game.cs`

**Проблема:** Эти методы должны быть в консольном приложении (`chess`), а не в библиотеке.

**Рекомендация:** 
- Вынести всю консольную логику в отдельный класс `ConsoleGameController` в проекте `chess`
- Оставить в `Game` только чистую бизнес-логику: валидацию ходов, управление состоянием игры
- `Game` должен предоставлять методы типа `MakeMove(from, to)`, `GetValidMoves(piece)`, `IsCheck()` и т.д.

### 1.2. Прямые вызовы `Console` в библиотеке
**Проблема:** В `ChessLib` есть прямые вызовы `Console`:
```csharp
// Game.cs:108
Console.WriteLine("Конец игры");

// Game.cs:330-331
Console.WriteLine("Шах и мат!");
Console.ReadLine();

// Game.cs:362, 366
Console.Clear();
Console.ReadLine();

// King.cs:62
Console.WriteLine(" ");  // отладочный вывод?
```

**Местоположение:** `ChessLib/Game.cs`, `ChessLib/King.cs`

**Рекомендация:** 
- Полностью убрать все вызовы `Console` из библиотеки
- Использовать события или колбэки для уведомления о событиях игры
- Или использовать `IView.Show()` для всех сообщений

### 1.3. Метод `CreateNewGame()` содержит консольный цикл
**Проблема:** Метод `CreateNewGame()` содержит игровой цикл с консольной логикой:
```csharp
public void CreateNewGame()
{
    while (!isGameOver)
    {
        GameProcess();  // содержит Console.Clear(), Console.ReadLine()
        if (CurrentPlayer > 2) CurrentPlayer -= 2;
    }
    Console.WriteLine("Конец игры");  // прямой вызов Console
}
```

**Рекомендация:** 
- Разделить на методы:
  - `StartNewGame()` - инициализация игры
  - `ProcessTurn()` - обработка одного хода (без UI логики)
  - Консольный цикл должен быть в `ConsoleGameController`

---

## 2. Нарушение принципа единственной ответственности (SRP)

### 2.1. Класс `Game` делает слишком много
**Проблема:** Класс `Game` объединяет множество ответственностей:
- Управление игровым процессом (правильно - должно быть в библиотеке)
- Обработка пользовательского ввода (`UserInput`, `ChosePiece`) - **НЕ должно быть в библиотеке**
- Визуализация (`ShowAvailableMoves`, `ShowAvailableAttacks`) - **НЕ должно быть в библиотеке**
- Управление фигурами (`GetPiecesStartPosition`, `RemoveDeadPieces`) - правильно
- Логика ходов (`ConsoleMove`, `MoveAfterCheck`) - частично правильно, но содержит UI логику
- Прямое использование `Console` - **НЕ должно быть в библиотеке**

**Местоположение:** `ChessLib/Game.cs`

**Рекомендация:** 
- **В библиотеке оставить:**
  - `MakeMove(from, to)` - выполнение хода
  - `GetValidMoves(piece)` - получение валидных ходов
  - `IsCheck()` - проверка шаха
  - `IsCheckmate()` - проверка мата
  - `GetGameState()` - получение состояния игры
- **Вынести в консольное приложение:**
  - Всю логику ввода/вывода
  - Игровой цикл
  - Отображение доступных ходов

### 2.2. `MainViewModel` содержит бизнес-логику вместо использования библиотеки
**Проблема:** ViewModel содержит 850+ строк кода с бизнес-логикой игры, которая должна быть в библиотеке:
- Логика проверки шаха (`IsCheck`, `KingMoveCheck`, `KingAttackCheck`) - должна использовать `Game.IsCheck()`
- Логика рокировки (`ShortCastleModel`, `LongCastleModel`) - должна использовать методы из библиотеки
- Логика взятия на проходе (`EnPassentModel`) - должна быть в библиотеке
- Прямая работа с `GameField.GetAtackStatus()`, `GameField.GetCheckStatusAfterMove()` - правильно, но слишком много деталей

**Местоположение:** `WPFChess/ViewModels/MainViewModel.cs`

**Проблема:** ViewModel знает слишком много о внутренней структуре библиотеки и дублирует логику.

**Рекомендация:** 
- ViewModel должен вызывать методы библиотеки: `game.MakeMove(from, to)`, `game.GetValidMoves(piece)`
- Вся валидация должна быть в библиотеке
- ViewModel должен только преобразовывать UI события в вызовы библиотеки и обновлять UI

### 2.3. `GameField` смешивает ответственности
**Проблема:** Класс объединяет:
- Представление доски (`Cell[,] Field`)
- Логику проверки правил (`GetCheckStatusAfterMove`, `IsCheck`)
- Логику клонирования (`HardCloningOfTheList`, `HardCloningOfTheField`)
- Преобразование форматов (`GetStringFromGameField`)

**Местоположение:** `ChessLib/GameField.cs`

**Рекомендация:** Разделить на:
- `Board` - представление доски
- `MoveValidator` - валидация ходов
- `BoardStateManager` - управление состоянием доски

## 3. Нарушение принципа инверсии зависимостей (DIP)

### 3.1. Прямые зависимости от `Console`
**Проблема:** Бизнес-логика напрямую использует `Console`:
```csharp
// Game.cs:108
Console.WriteLine("Конец игры");

// Game.cs:330-331
Console.WriteLine("Шах и мат!");
Console.ReadLine();

// Game.cs:362, 366
Console.Clear();
Console.ReadLine();

// King.cs:62
Console.WriteLine(" ");
```

**Местоположение:** `ChessLib/Game.cs`, `ChessLib/King.cs`

**Рекомендация:** 
- Использовать `IView.Show()` для всех сообщений (уже есть интерфейс!)
- Убрать прямые вызовы `Console` из библиотеки
- Консольные операции (`Console.ReadLine()`, `Console.Clear()`) должны быть только в `ConsoleView` или консольном контроллере

### 3.2. Смешивание абстракций и конкретных реализаций
**Проблема:** `Game` использует `IView` для визуализации (правильно!), но также напрямую вызывает `Console` (неправильно!).

**Рекомендация:** Полностью убрать прямые вызовы `Console` из библиотеки, использовать только `IView`.

## 4. Дублирование кода

### 4.1. Дублирование конструкторов `Game`
**Проблема:** Два конструктора с почти идентичной логикой:
```csharp
public Game() { /* ... */ }
public Game(IView view) { /* ... */ }
```
Дублируется создание фигур, игроков, инициализация поля.

**Местоположение:** `ChessLib/Game.cs:373-422`

**Рекомендация:** Использовать общий метод инициализации или делегирующий конструктор.

### 4.2. Дублирование методов `CheckIfPieceWasKilled`
**Проблема:** Два метода с похожей логикой:
- `CheckIfPieceWasKilled(List<IPiece>, uint, List<(int, int)>)` - для консоли
- `CheckIfPieceWasKilled((int, int), (int, int), string[,], List<IPiece>)` - для WPF

**Местоположение:** `ChessLib/Game.cs:238-261`

**Рекомендация:** Объединить в один метод с перегрузками или использовать единый интерфейс.

### 4.3. Дублирование методов `GetCheckStatusAfterMove`
**Проблема:** Два статических метода с разной логикой:
- `GetCheckStatusAfterMove(List<IPiece>, IPiece, (int, int))` - упрощенная версия
- `GetCheckStatusAfterMove(List<IPiece>, IPiece, (int, int), Player)` - полная версия

**Местоположение:** `ChessLib/GameField.cs:35-101`

**Рекомендация:** Удалить упрощенную версию или объединить логику.

### 4.4. Дублирование создания игроков
**Проблема:** Логика создания игроков дублируется в обоих конструкторах `Game`.

**Рекомендация:** Вынести в отдельный метод `CreatePlayers()`.

## 5. Нарушение принципа открытости/закрытости (OCP)

### 5.1. Цепочка if-else для клонирования фигур
**Проблема:** Метод `HardCloningOfTheList` использует if-else для определения типа фигуры:
```csharp
if (piece is Pawn) { ... }
else if (piece is Rook) { ... }
else if (piece is Bishop) { ... }
// и т.д.
```

**Местоположение:** `ChessLib/GameField.cs:171-203`

**Проблема:** При добавлении нового типа фигуры нужно изменять этот метод.

**Рекомендация:** Использовать паттерн Factory или полиморфизм через `ICloneable`.

## 6. Магические числа и строки

### 6.1. Хардкод размеров доски
**Проблема:** Размер доски (8x8) захардкожен по всему коду:
```csharp
string[,] GameField = new string[8, 8];
Cell[,] Field = new Cell[8, 8];
for (int i = 0; i < 8; i++)
```

**Рекомендация:** Вынести в константы:
```csharp
public const int BoardSize = 8;
```

### 6.2. Магические строки для фигур
**Проблема:** Строки для представления фигур захардкожены:
```csharp
pieces = "kbnpqr";  // для белых
pieces = "KBNPQR";  // для черных
```

**Местоположение:** `ChessLib/Pawn.cs:148-153`, `ChessLib/King.cs:132-139`

**Рекомендация:** Использовать enum или константы.

### 6.3. Хардкод начальных позиций
**Проблема:** Начальные позиции фигур захардкожены в методе `GetPiecesStartPosition`.

**Местоположение:** `ChessLib/Game.cs:57-95`

**Рекомендация:** Вынести в конфигурацию или использовать Factory паттерн.

## 7. Проблемы с именованием

### 7.1. Неинформативные имена
- `pieces` (строка) вместо `enemyPieceSymbols`
- `numOfElements` вместо `pieceIndex`
- `chosenElement` вместо `selectedPieceIndex`
- `GameFieldString` вместо `boardStringRepresentation`

### 7.2. Непоследовательное именование
- `CurrentPlayer` (int) в `Game`
- `currentPlayer` (int) в `MainViewModel`
- `curretnPlayer` (опечатка) в `GameField.Update`

### 7.3. Комментарии вместо имен
```csharp
//хз  - Game.cs:375
```

## 8. Нарушение инкапсуляции

### 8.1. Публичные поля вместо свойств
**Проблема:** Публичные поля с нарушением инкапсуляции:
```csharp
public int CurrentPlayer;  // должно быть свойство
public List<IPiece> Pieces;  // должно быть свойство с защитой
public bool isGameOver;  // нарушение соглашения об именовании
```

**Местоположение:** `ChessLib/Game.cs:26, 30, 34`

**Рекомендация:** Использовать свойства с приватными сеттерами где необходимо.

### 8.2. Прямое изменение состояния извне
**Проблема:** Позиции фигур изменяются напрямую:
```csharp
pieces.Find(x => x.Position == AvailableMoves[...]).IsDead = true;
currentPlayer.MyPieces[...].Position = ValidMoves[...];
```

**Рекомендация:** Использовать методы для изменения состояния с валидацией.

## 9. Отсутствие валидации

### 9.1. Нет проверки границ доски
**Проблема:** Методы могут выходить за границы массива:
```csharp
GameField[Position.Item1 + MoveDir[0].Item1, Position.Item2 + MoveDir[0].Item2]
```

**Рекомендация:** Добавить валидацию координат перед доступом к массиву.

### 9.2. Нет проверки null
**Проблема:** Возможны NullReferenceException:
```csharp
Pieces.Find(x => x.Position == AvailableMoves[...]).IsDead = true;
// Если Find вернет null, будет исключение
```

**Рекомендация:** Добавить проверки на null или использовать `FirstOrDefault` с проверкой.

## 10. Проблемы с тестируемостью

### 10.1. Сложно тестировать из-за зависимостей
**Проблема:** 
- Прямые зависимости от `Console`
- Статические методы в `GameField`
- Смешивание создания объектов с логикой

**Рекомендация:** 
- Использовать Dependency Injection
- Вынести статические методы в сервисы
- Использовать Factory паттерны

### 10.2. Нет интерфейсов для тестирования
**Проблема:** Классы не имеют интерфейсов, сложно создавать моки.

**Рекомендация:** Создать интерфейсы для основных компонентов (`IGame`, `IBoard`, `IMoveValidator`).

## 11. Проблемы с состоянием

### 11.1. Множественные источники истины
**Проблема:** Состояние игры хранится в разных местах:
- `Game.Pieces` - список фигур
- `Game.GameField` - игровое поле
- `GameField.Field` - внутреннее представление доски
- `MainViewModel.pieces` - копия фигур для WPF

**Рекомендация:** Использовать единый источник истины (например, `GameState`).

### 11.2. Несогласованность данных
**Проблема:** `GameFieldString` и `GameField` могут рассинхронизироваться.

**Рекомендация:** Использовать один источник данных и преобразовывать при необходимости.

## 12. Архитектурные антипаттерны

### 12.1. God Object
**Проблема:** `Game` и `MainViewModel` являются "божественными объектами" - делают слишком много.

### 12.2. Feature Envy
**Проблема:** `MainViewModel` слишком много знает о внутренней структуре `Game` и `GameField`.

### 12.3. Data Clumps
**Проблема:** Кортежи `(int, int)` используются везде вместо структуры `Position`.

**Рекомендация:** Создать структуру `Position`:
```csharp
public struct Position
{
    public int X { get; }
    public int Y { get; }
}
```

## 13. Правильная архитектура (как должно быть)

### 13.1. Разделение ответственностей

**ChessLib (библиотека) должна содержать:**
```
ChessLib/
├── Domain/
│   ├── Pieces/ (Pawn, King, Queen, etc.)
│   ├── Board/ (GameField, Cell)
│   └── Rules/ (MoveValidator, CheckDetector)
├── Game/
│   ├── Game.cs (чистая бизнес-логика)
│   ├── GameState.cs
│   └── MoveResult.cs
└── Interfaces/
    └── IView.cs (для визуализации)
```

**Методы Game должны быть:**
```csharp
public class Game
{
    public MoveResult MakeMove(Position from, Position to);
    public List<Position> GetValidMoves(Position piecePosition);
    public bool IsCheck(PieceColor color);
    public bool IsCheckmate(PieceColor color);
    public GameState GetState();
    public void StartNewGame();
}
```

**Консольное приложение должно:**
```
chess/
├── Controllers/
│   └── ConsoleGameController.cs (игровой цикл, ввод/вывод)
└── Program.cs
```

**WPF приложение должно:**
```
WPFChess/
├── ViewModels/
│   └── MainViewModel.cs (только UI логика, вызывает Game)
└── Views/
    └── MainWindow.xaml
```

## Приоритеты исправления

### Критический приоритет (нарушение архитектурной идеи):
1. **Вынести консольную логику из ChessLib в консольное приложение**
   - Переместить `UserInput`, `ChosePiece`, `ShowAvailableMoves`, `ShowAvailableAttacks`, `ConsoleMove`, `MoveAfterCheck` в `chess` проект
   - Создать `ConsoleGameController` для управления консольным игровым циклом

2. **Убрать все прямые вызовы `Console` из ChessLib**
   - Заменить на использование `IView.Show()` или события
   - Удалить `Console.WriteLine`, `Console.ReadLine`, `Console.Clear` из библиотеки

3. **Рефакторинг `Game` для чистого API**
   - Методы должны быть: `MakeMove(from, to)`, `GetValidMoves(piece)`, `IsCheck()`
   - Убрать методы с UI логикой

4. **Упростить `MainViewModel`**
   - Убрать дублирование бизнес-логики
   - Использовать методы библиотеки вместо прямой работы с `GameField`

### Высокий приоритет:
5. Добавить валидацию и проверки на null
6. Устранить дублирование кода (конструкторы, методы)
7. Исправить проблемы с инкапсуляцией (публичные поля → свойства)

### Средний приоритет:
8. Вынести магические числа в константы
9. Улучшить именование
10. Исправить цепочку if-else для клонирования (использовать полиморфизм)

### Низкий приоритет:
11. Рефакторинг для улучшения тестируемости
12. Создание интерфейсов для основных компонентов
13. Использование дополнительных паттернов проектирования

